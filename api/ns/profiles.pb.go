// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: profiles.proto

/*
	Package ns is a generated protocol buffer package.

	It is generated from these files:
		profiles.proto
		ns.proto

	It has these top-level messages:
		ServiceProfile
		DeviceProfile
		RoutingProfile
		CreateServiceProfileRequest
		CreateServiceProfileResponse
		GetServiceProfileRequest
		GetServiceProfileResponse
		UpdateServiceProfileRequest
		UpdateServiceProfileResponse
		DeleteServiceProfileRequest
		DeleteServiceProfileResponse
		CreateRoutingProfileRequest
		CreateRoutingProfileResponse
		GetRoutingProfileRequest
		GetRoutingProfileResponse
		UpdateRoutingProfileRequest
		UpdateRoutingProfileResponse
		DeleteRoutingProfileRequest
		DeleteRoutingProfileResponse
		CreateDeviceProfileRequest
		CreateDeviceProfileResponse
		GetDeviceProfileRequest
		GetDeviceProfileResponse
		UpdateDeviceProfileRequest
		UpdateDeviceProfileResponse
		DeleteDeviceProfileRequest
		DeleteDeviceProfileResponse
		Device
		CreateDeviceRequest
		CreateDeviceResponse
		GetDeviceRequest
		GetDeviceResponse
		UpdateDeviceRequest
		UpdateDeviceResponse
		DeleteDeviceRequest
		DeleteDeviceResponse
		DeviceActivation
		ActivateDeviceRequest
		ActivateDeviceResponse
		DeactivateDeviceRequest
		DeactivateDeviceResponse
		GetDeviceActivationRequest
		GetDeviceActivationResponse
		GetRandomDevAddrRequest
		GetRandomDevAddrResponse
		CreateMACCommandQueueItemRequest
		CreateMACCommandQueueItemResponse
		SendProprietaryPayloadRequest
		SendProprietaryPayloadResponse
		Gateway
		CreateGatewayRequest
		CreateGatewayResponse
		GetGatewayRequest
		GetGatewayResponse
		UpdateGatewayRequest
		UpdateGatewayResponse
		DeleteGatewayRequest
		DeleteGatewayResponse
		GatewayStats
		GetGatewayStatsRequest
		GetGatewayStatsResponse
		DeviceQueueItem
		CreateDeviceQueueItemRequest
		CreateDeviceQueueItemResponse
		FlushDeviceQueueForDevEUIRequest
		FlushDeviceQueueForDevEUIResponse
		GetDeviceQueueItemsForDevEUIRequest
		GetDeviceQueueItemsForDevEUIResponse
		GetNextDownlinkFCntForDevEUIRequest
		GetNextDownlinkFCntForDevEUIResponse
		StreamFrameLogsForGatewayRequest
		StreamFrameLogsForGatewayResponse
		StreamFrameLogsForDeviceRequest
		StreamFrameLogsForDeviceResponse
		DataRate
		UplinkTXInfo
		UplinkRXInfo
		UplinkFrameLog
		DownlinkTXInfo
		DownlinkFrameLog
		GetVersionRequest
		GetVersionResponse
		GatewayProfile
		GatewayProfileExtraChannel
		CreateGatewayProfileRequest
		CreateGatewayProfileResponse
		GetGatewayProfileRequest
		GetGatewayProfileResponse
		UpdateGatewayProfileRequest
		UpdateGatewayProfileResponse
		DeleteGatewayProfileRequest
		DeleteGatewayProfileResponse
*/
package ns

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import github_com_brocaar_loraserver_api_types "github.com/brocaar/loraserver/api/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type RatePolicy int32

const (
	// Drop
	RatePolicy_DROP RatePolicy = 0
	// Mark
	RatePolicy_MARK RatePolicy = 1
)

var RatePolicy_name = map[int32]string{
	0: "DROP",
	1: "MARK",
}
var RatePolicy_value = map[string]int32{
	"DROP": 0,
	"MARK": 1,
}

func (x RatePolicy) String() string {
	return proto.EnumName(RatePolicy_name, int32(x))
}
func (RatePolicy) EnumDescriptor() ([]byte, []int) { return fileDescriptorProfiles, []int{0} }

type ServiceProfile struct {
	// Service-profile ID.
	ID github_com_brocaar_loraserver_api_types.UUID `protobuf:"bytes,1,opt,name=id,proto3,customtype=github.com/brocaar/loraserver/api/types.UUID" json:"id"`
	// Token bucket filling rate, including ACKs (packet/h).
	ULRate uint32 `protobuf:"varint,2,opt,name=ul_rate,json=ulRate,proto3" json:"ul_rate,omitempty"`
	// Token bucket burst size.
	ULBucketSize uint32 `protobuf:"varint,3,opt,name=ul_bucket_size,json=ulBucketSize,proto3" json:"ul_bucket_size,omitempty"`
	// Drop or mark when exceeding ULRate.
	ULRatePolicy RatePolicy `protobuf:"varint,4,opt,name=ul_rate_policy,json=ulRatePolicy,proto3,enum=ns.RatePolicy" json:"ul_rate_policy,omitempty"`
	// Token bucket filling rate, including ACKs (packet/h).
	DLRate uint32 `protobuf:"varint,5,opt,name=dl_rate,json=dlRate,proto3" json:"dl_rate,omitempty"`
	// Token bucket burst size.
	DLBucketSize uint32 `protobuf:"varint,6,opt,name=dl_bucket_size,json=dlBucketSize,proto3" json:"dl_bucket_size,omitempty"`
	// Drop or mark when exceeding DLRate.
	DLRatePolicy RatePolicy `protobuf:"varint,7,opt,name=dl_rate_policy,json=dlRatePolicy,proto3,enum=ns.RatePolicy" json:"dl_rate_policy,omitempty"`
	// GW metadata (RSSI, SNR, GW geoloc., etc.) are added to the packet sent to AS.
	AddGWMetaData bool `protobuf:"varint,8,opt,name=add_gw_metadata,json=addGwMetadata,proto3" json:"add_gw_metadata,omitempty"`
	// Frequency to initiate an End-Device status request (request/day).
	DevStatusReqFreq uint32 `protobuf:"varint,9,opt,name=dev_status_req_freq,json=devStatusReqFreq,proto3" json:"dev_status_req_freq,omitempty"`
	// Report End-Device battery level to AS.
	ReportDevStatusBattery bool `protobuf:"varint,10,opt,name=report_dev_status_battery,json=reportDevStatusBattery,proto3" json:"report_dev_status_battery,omitempty"`
	// Report End-Device margin to AS.
	ReportDevStatusMargin bool `protobuf:"varint,11,opt,name=report_dev_status_margin,json=reportDevStatusMargin,proto3" json:"report_dev_status_margin,omitempty"`
	// Minimum allowed data rate. Used for ADR.
	DRMin uint32 `protobuf:"varint,12,opt,name=dr_min,json=drMin,proto3" json:"dr_min,omitempty"`
	// Maximum allowed data rate. Used for ADR.
	DRMax uint32 `protobuf:"varint,13,opt,name=dr_max,json=drMax,proto3" json:"dr_max,omitempty"`
	// Channel mask. sNS does not have to obey (i.e., informative).
	ChannelMask []byte `protobuf:"bytes,14,opt,name=channel_mask,json=channelMask,proto3" json:"channel_mask,omitempty"`
	// Passive Roaming allowed.
	PRAllowed bool `protobuf:"varint,15,opt,name=pr_allowed,json=prAllowed,proto3" json:"pr_allowed,omitempty"`
	// Handover Roaming allowed.
	HRAllowed bool `protobuf:"varint,16,opt,name=hr_allowed,json=hrAllowed,proto3" json:"hr_allowed,omitempty"`
	// Roaming Activation allowed.
	RAAllowed bool `protobuf:"varint,17,opt,name=ra_allowed,json=raAllowed,proto3" json:"ra_allowed,omitempty"`
	// Enable network geolocation service.
	NwkGeoLoc bool `protobuf:"varint,18,opt,name=nwk_geo_loc,json=nwkGeoLoc,proto3" json:"nwk_geo_loc,omitempty"`
	// Target Packet Error Rate.
	TargetPER uint32 `protobuf:"varint,19,opt,name=target_per,json=targetPer,proto3" json:"target_per,omitempty"`
	// Minimum number of receiving GWs (informative).
	MinGWDiversity uint32 `protobuf:"varint,20,opt,name=min_gw_diversity,json=minGwDiversity,proto3" json:"min_gw_diversity,omitempty"`
}

func (m *ServiceProfile) Reset()                    { *m = ServiceProfile{} }
func (m *ServiceProfile) String() string            { return proto.CompactTextString(m) }
func (*ServiceProfile) ProtoMessage()               {}
func (*ServiceProfile) Descriptor() ([]byte, []int) { return fileDescriptorProfiles, []int{0} }

func (m *ServiceProfile) GetULRate() uint32 {
	if m != nil {
		return m.ULRate
	}
	return 0
}

func (m *ServiceProfile) GetULBucketSize() uint32 {
	if m != nil {
		return m.ULBucketSize
	}
	return 0
}

func (m *ServiceProfile) GetULRatePolicy() RatePolicy {
	if m != nil {
		return m.ULRatePolicy
	}
	return RatePolicy_DROP
}

func (m *ServiceProfile) GetDLRate() uint32 {
	if m != nil {
		return m.DLRate
	}
	return 0
}

func (m *ServiceProfile) GetDLBucketSize() uint32 {
	if m != nil {
		return m.DLBucketSize
	}
	return 0
}

func (m *ServiceProfile) GetDLRatePolicy() RatePolicy {
	if m != nil {
		return m.DLRatePolicy
	}
	return RatePolicy_DROP
}

func (m *ServiceProfile) GetAddGWMetaData() bool {
	if m != nil {
		return m.AddGWMetaData
	}
	return false
}

func (m *ServiceProfile) GetDevStatusReqFreq() uint32 {
	if m != nil {
		return m.DevStatusReqFreq
	}
	return 0
}

func (m *ServiceProfile) GetReportDevStatusBattery() bool {
	if m != nil {
		return m.ReportDevStatusBattery
	}
	return false
}

func (m *ServiceProfile) GetReportDevStatusMargin() bool {
	if m != nil {
		return m.ReportDevStatusMargin
	}
	return false
}

func (m *ServiceProfile) GetDRMin() uint32 {
	if m != nil {
		return m.DRMin
	}
	return 0
}

func (m *ServiceProfile) GetDRMax() uint32 {
	if m != nil {
		return m.DRMax
	}
	return 0
}

func (m *ServiceProfile) GetChannelMask() []byte {
	if m != nil {
		return m.ChannelMask
	}
	return nil
}

func (m *ServiceProfile) GetPRAllowed() bool {
	if m != nil {
		return m.PRAllowed
	}
	return false
}

func (m *ServiceProfile) GetHRAllowed() bool {
	if m != nil {
		return m.HRAllowed
	}
	return false
}

func (m *ServiceProfile) GetRAAllowed() bool {
	if m != nil {
		return m.RAAllowed
	}
	return false
}

func (m *ServiceProfile) GetNwkGeoLoc() bool {
	if m != nil {
		return m.NwkGeoLoc
	}
	return false
}

func (m *ServiceProfile) GetTargetPER() uint32 {
	if m != nil {
		return m.TargetPER
	}
	return 0
}

func (m *ServiceProfile) GetMinGWDiversity() uint32 {
	if m != nil {
		return m.MinGWDiversity
	}
	return 0
}

type DeviceProfile struct {
	// Device-profile ID.
	ID github_com_brocaar_loraserver_api_types.UUID `protobuf:"bytes,1,opt,name=id,proto3,customtype=github.com/brocaar/loraserver/api/types.UUID" json:"id"`
	// End-Device supports Class B.
	SupportsClassB bool `protobuf:"varint,2,opt,name=supports_class_b,json=supportsClassB,proto3" json:"supports_class_b,omitempty"`
	// Maximum delay for the End-Device to answer a MAC request or a confirmed DL frame (mandatory if class B mode supported).
	ClassBTimeout uint32 `protobuf:"varint,3,opt,name=class_b_timeout,json=classBTimeout,proto3" json:"class_b_timeout,omitempty"`
	// Mandatory if class B mode supported.
	PingSlotPeriod uint32 `protobuf:"varint,4,opt,name=ping_slot_period,json=pingSlotPeriod,proto3" json:"ping_slot_period,omitempty"`
	// Mandatory if class B mode supported.
	PingSlotDR uint32 `protobuf:"varint,5,opt,name=ping_slot_dr,json=pingSlotDr,proto3" json:"ping_slot_dr,omitempty"`
	// Mandatory if class B mode supported.
	PingSlotFreq uint32 `protobuf:"varint,6,opt,name=ping_slot_freq,json=pingSlotFreq,proto3" json:"ping_slot_freq,omitempty"`
	// End-Device supports Class C.
	SupportsClassC bool `protobuf:"varint,7,opt,name=supports_class_c,json=supportsClassC,proto3" json:"supports_class_c,omitempty"`
	// Maximum delay for the End-Device to answer a MAC request or a confirmed DL frame (mandatory if class C mode supported).
	ClassCTimeout uint32 `protobuf:"varint,8,opt,name=class_c_timeout,json=classCTimeout,proto3" json:"class_c_timeout,omitempty"`
	// Version of the LoRaWAN supported by the End-Device.
	MACVersion string `protobuf:"bytes,9,opt,name=mac_version,json=macVersion,proto3" json:"mac_version,omitempty"`
	// Revision of the Regional Parameters document supported by the End-Device.
	RegParamsRevision string `protobuf:"bytes,10,opt,name=reg_params_revision,json=regParamsRevision,proto3" json:"reg_params_revision,omitempty"`
	// Class A RX1 delay (mandatory for ABP).
	RXDelay1 uint32 `protobuf:"varint,11,opt,name=rx_delay_1,json=rxDelay1,proto3" json:"rx_delay_1,omitempty"`
	// RX1 data rate offset (mandatory for ABP).
	RXDROffset1 uint32 `protobuf:"varint,12,opt,name=rx_dr_offset_1,json=rxDrOffset1,proto3" json:"rx_dr_offset_1,omitempty"`
	// RX2 data rate (mandatory for ABP).
	RXDataRate2 uint32 `protobuf:"varint,13,opt,name=rx_datarate_2,json=rxDatarate2,proto3" json:"rx_datarate_2,omitempty"`
	// RX2 channel frequency (mandatory for ABP).
	RXFreq2 uint32 `protobuf:"varint,14,opt,name=rx_freq_2,json=rxFreq2,proto3" json:"rx_freq_2,omitempty"`
	// List of factory-preset frequencies (mandatory for ABP).
	FactoryPresetFreqs []uint32 `protobuf:"varint,15,rep,packed,name=factory_preset_freqs,json=factoryPresetFreqs" json:"factory_preset_freqs,omitempty"`
	// Maximum EIRP supported by the End-Device.
	MaxEIRP uint32 `protobuf:"varint,16,opt,name=max_eirp,json=maxEirp,proto3" json:"max_eirp,omitempty"`
	// Maximum duty cycle supported by the End-Device.
	MaxDutyCycle uint32 `protobuf:"varint,17,opt,name=max_duty_cycle,json=maxDutyCycle,proto3" json:"max_duty_cycle,omitempty"`
	// End-Device supports Join (OTAA) or not (ABP).
	SupportsJoin bool `protobuf:"varint,18,opt,name=supports_join,json=supportsJoin,proto3" json:"supports_join,omitempty"`
	// RF region name.
	RFRegion string `protobuf:"bytes,19,opt,name=rf_region,json=rfRegion,proto3" json:"rf_region,omitempty"`
	// End-Device uses 32bit FCnt (mandatory for LoRaWAN 1.0 End-Device).
	Supports32BitFCnt bool `protobuf:"varint,20,opt,name=supports_32bit_f_cnt,json=supports32bitFCnt,proto3" json:"supports_32bit_f_cnt,omitempty"`
}

func (m *DeviceProfile) Reset()                    { *m = DeviceProfile{} }
func (m *DeviceProfile) String() string            { return proto.CompactTextString(m) }
func (*DeviceProfile) ProtoMessage()               {}
func (*DeviceProfile) Descriptor() ([]byte, []int) { return fileDescriptorProfiles, []int{1} }

func (m *DeviceProfile) GetSupportsClassB() bool {
	if m != nil {
		return m.SupportsClassB
	}
	return false
}

func (m *DeviceProfile) GetClassBTimeout() uint32 {
	if m != nil {
		return m.ClassBTimeout
	}
	return 0
}

func (m *DeviceProfile) GetPingSlotPeriod() uint32 {
	if m != nil {
		return m.PingSlotPeriod
	}
	return 0
}

func (m *DeviceProfile) GetPingSlotDR() uint32 {
	if m != nil {
		return m.PingSlotDR
	}
	return 0
}

func (m *DeviceProfile) GetPingSlotFreq() uint32 {
	if m != nil {
		return m.PingSlotFreq
	}
	return 0
}

func (m *DeviceProfile) GetSupportsClassC() bool {
	if m != nil {
		return m.SupportsClassC
	}
	return false
}

func (m *DeviceProfile) GetClassCTimeout() uint32 {
	if m != nil {
		return m.ClassCTimeout
	}
	return 0
}

func (m *DeviceProfile) GetMACVersion() string {
	if m != nil {
		return m.MACVersion
	}
	return ""
}

func (m *DeviceProfile) GetRegParamsRevision() string {
	if m != nil {
		return m.RegParamsRevision
	}
	return ""
}

func (m *DeviceProfile) GetRXDelay1() uint32 {
	if m != nil {
		return m.RXDelay1
	}
	return 0
}

func (m *DeviceProfile) GetRXDROffset1() uint32 {
	if m != nil {
		return m.RXDROffset1
	}
	return 0
}

func (m *DeviceProfile) GetRXDataRate2() uint32 {
	if m != nil {
		return m.RXDataRate2
	}
	return 0
}

func (m *DeviceProfile) GetRXFreq2() uint32 {
	if m != nil {
		return m.RXFreq2
	}
	return 0
}

func (m *DeviceProfile) GetFactoryPresetFreqs() []uint32 {
	if m != nil {
		return m.FactoryPresetFreqs
	}
	return nil
}

func (m *DeviceProfile) GetMaxEIRP() uint32 {
	if m != nil {
		return m.MaxEIRP
	}
	return 0
}

func (m *DeviceProfile) GetMaxDutyCycle() uint32 {
	if m != nil {
		return m.MaxDutyCycle
	}
	return 0
}

func (m *DeviceProfile) GetSupportsJoin() bool {
	if m != nil {
		return m.SupportsJoin
	}
	return false
}

func (m *DeviceProfile) GetRFRegion() string {
	if m != nil {
		return m.RFRegion
	}
	return ""
}

func (m *DeviceProfile) GetSupports32BitFCnt() bool {
	if m != nil {
		return m.Supports32BitFCnt
	}
	return false
}

type RoutingProfile struct {
	// ID of the routing profile.
	ID github_com_brocaar_loraserver_api_types.UUID `protobuf:"bytes,1,opt,name=id,proto3,customtype=github.com/brocaar/loraserver/api/types.UUID" json:"id"`
	// Application-server ID.
	ASID string `protobuf:"bytes,2,opt,name=as_id,json=asId,proto3" json:"as_id,omitempty"`
	// CA certificate for connecting to the AS.
	CACert string `protobuf:"bytes,3,opt,name=ca_cert,json=caCert,proto3" json:"ca_cert,omitempty"`
	// TLS certificate for connecting to the AS.
	TLSCert string `protobuf:"bytes,4,opt,name=tls_cert,json=tlsCert,proto3" json:"tls_cert,omitempty"`
	// TLS key for connecting to the AS.
	// Note: when retrieving the routing-profile, the tls_key is not returned
	// for security reasons. When updating the routing-profile, an empty tls_key
	// does not clear the certificate, unless the tls_cert is also left blank.
	TLSKey string `protobuf:"bytes,5,opt,name=tls_key,json=tlsKey,proto3" json:"tls_key,omitempty"`
}

func (m *RoutingProfile) Reset()                    { *m = RoutingProfile{} }
func (m *RoutingProfile) String() string            { return proto.CompactTextString(m) }
func (*RoutingProfile) ProtoMessage()               {}
func (*RoutingProfile) Descriptor() ([]byte, []int) { return fileDescriptorProfiles, []int{2} }

func (m *RoutingProfile) GetASID() string {
	if m != nil {
		return m.ASID
	}
	return ""
}

func (m *RoutingProfile) GetCACert() string {
	if m != nil {
		return m.CACert
	}
	return ""
}

func (m *RoutingProfile) GetTLSCert() string {
	if m != nil {
		return m.TLSCert
	}
	return ""
}

func (m *RoutingProfile) GetTLSKey() string {
	if m != nil {
		return m.TLSKey
	}
	return ""
}

func init() {
	proto.RegisterType((*ServiceProfile)(nil), "ns.ServiceProfile")
	proto.RegisterType((*DeviceProfile)(nil), "ns.DeviceProfile")
	proto.RegisterType((*RoutingProfile)(nil), "ns.RoutingProfile")
	proto.RegisterEnum("ns.RatePolicy", RatePolicy_name, RatePolicy_value)
}
func (m *ServiceProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceProfile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProfiles(dAtA, i, uint64(m.ID.Size()))
	n1, err := m.ID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.ULRate != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.ULRate))
	}
	if m.ULBucketSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.ULBucketSize))
	}
	if m.ULRatePolicy != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.ULRatePolicy))
	}
	if m.DLRate != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.DLRate))
	}
	if m.DLBucketSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.DLBucketSize))
	}
	if m.DLRatePolicy != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.DLRatePolicy))
	}
	if m.AddGWMetaData {
		dAtA[i] = 0x40
		i++
		if m.AddGWMetaData {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DevStatusReqFreq != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.DevStatusReqFreq))
	}
	if m.ReportDevStatusBattery {
		dAtA[i] = 0x50
		i++
		if m.ReportDevStatusBattery {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReportDevStatusMargin {
		dAtA[i] = 0x58
		i++
		if m.ReportDevStatusMargin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DRMin != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.DRMin))
	}
	if m.DRMax != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.DRMax))
	}
	if len(m.ChannelMask) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(len(m.ChannelMask)))
		i += copy(dAtA[i:], m.ChannelMask)
	}
	if m.PRAllowed {
		dAtA[i] = 0x78
		i++
		if m.PRAllowed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HRAllowed {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.HRAllowed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RAAllowed {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.RAAllowed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NwkGeoLoc {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.NwkGeoLoc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TargetPER != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.TargetPER))
	}
	if m.MinGWDiversity != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.MinGWDiversity))
	}
	return i, nil
}

func (m *DeviceProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceProfile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProfiles(dAtA, i, uint64(m.ID.Size()))
	n2, err := m.ID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if m.SupportsClassB {
		dAtA[i] = 0x10
		i++
		if m.SupportsClassB {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ClassBTimeout != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.ClassBTimeout))
	}
	if m.PingSlotPeriod != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.PingSlotPeriod))
	}
	if m.PingSlotDR != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.PingSlotDR))
	}
	if m.PingSlotFreq != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.PingSlotFreq))
	}
	if m.SupportsClassC {
		dAtA[i] = 0x38
		i++
		if m.SupportsClassC {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ClassCTimeout != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.ClassCTimeout))
	}
	if len(m.MACVersion) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(len(m.MACVersion)))
		i += copy(dAtA[i:], m.MACVersion)
	}
	if len(m.RegParamsRevision) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(len(m.RegParamsRevision)))
		i += copy(dAtA[i:], m.RegParamsRevision)
	}
	if m.RXDelay1 != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.RXDelay1))
	}
	if m.RXDROffset1 != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.RXDROffset1))
	}
	if m.RXDataRate2 != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.RXDataRate2))
	}
	if m.RXFreq2 != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.RXFreq2))
	}
	if len(m.FactoryPresetFreqs) > 0 {
		dAtA4 := make([]byte, len(m.FactoryPresetFreqs)*10)
		var j3 int
		for _, num := range m.FactoryPresetFreqs {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x7a
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if m.MaxEIRP != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.MaxEIRP))
	}
	if m.MaxDutyCycle != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(m.MaxDutyCycle))
	}
	if m.SupportsJoin {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.SupportsJoin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.RFRegion) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(len(m.RFRegion)))
		i += copy(dAtA[i:], m.RFRegion)
	}
	if m.Supports32BitFCnt {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.Supports32BitFCnt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RoutingProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoutingProfile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProfiles(dAtA, i, uint64(m.ID.Size()))
	n5, err := m.ID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if len(m.ASID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(len(m.ASID)))
		i += copy(dAtA[i:], m.ASID)
	}
	if len(m.CACert) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(len(m.CACert)))
		i += copy(dAtA[i:], m.CACert)
	}
	if len(m.TLSCert) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(len(m.TLSCert)))
		i += copy(dAtA[i:], m.TLSCert)
	}
	if len(m.TLSKey) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintProfiles(dAtA, i, uint64(len(m.TLSKey)))
		i += copy(dAtA[i:], m.TLSKey)
	}
	return i, nil
}

func encodeVarintProfiles(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ServiceProfile) Size() (n int) {
	var l int
	_ = l
	l = m.ID.Size()
	n += 1 + l + sovProfiles(uint64(l))
	if m.ULRate != 0 {
		n += 1 + sovProfiles(uint64(m.ULRate))
	}
	if m.ULBucketSize != 0 {
		n += 1 + sovProfiles(uint64(m.ULBucketSize))
	}
	if m.ULRatePolicy != 0 {
		n += 1 + sovProfiles(uint64(m.ULRatePolicy))
	}
	if m.DLRate != 0 {
		n += 1 + sovProfiles(uint64(m.DLRate))
	}
	if m.DLBucketSize != 0 {
		n += 1 + sovProfiles(uint64(m.DLBucketSize))
	}
	if m.DLRatePolicy != 0 {
		n += 1 + sovProfiles(uint64(m.DLRatePolicy))
	}
	if m.AddGWMetaData {
		n += 2
	}
	if m.DevStatusReqFreq != 0 {
		n += 1 + sovProfiles(uint64(m.DevStatusReqFreq))
	}
	if m.ReportDevStatusBattery {
		n += 2
	}
	if m.ReportDevStatusMargin {
		n += 2
	}
	if m.DRMin != 0 {
		n += 1 + sovProfiles(uint64(m.DRMin))
	}
	if m.DRMax != 0 {
		n += 1 + sovProfiles(uint64(m.DRMax))
	}
	l = len(m.ChannelMask)
	if l > 0 {
		n += 1 + l + sovProfiles(uint64(l))
	}
	if m.PRAllowed {
		n += 2
	}
	if m.HRAllowed {
		n += 3
	}
	if m.RAAllowed {
		n += 3
	}
	if m.NwkGeoLoc {
		n += 3
	}
	if m.TargetPER != 0 {
		n += 2 + sovProfiles(uint64(m.TargetPER))
	}
	if m.MinGWDiversity != 0 {
		n += 2 + sovProfiles(uint64(m.MinGWDiversity))
	}
	return n
}

func (m *DeviceProfile) Size() (n int) {
	var l int
	_ = l
	l = m.ID.Size()
	n += 1 + l + sovProfiles(uint64(l))
	if m.SupportsClassB {
		n += 2
	}
	if m.ClassBTimeout != 0 {
		n += 1 + sovProfiles(uint64(m.ClassBTimeout))
	}
	if m.PingSlotPeriod != 0 {
		n += 1 + sovProfiles(uint64(m.PingSlotPeriod))
	}
	if m.PingSlotDR != 0 {
		n += 1 + sovProfiles(uint64(m.PingSlotDR))
	}
	if m.PingSlotFreq != 0 {
		n += 1 + sovProfiles(uint64(m.PingSlotFreq))
	}
	if m.SupportsClassC {
		n += 2
	}
	if m.ClassCTimeout != 0 {
		n += 1 + sovProfiles(uint64(m.ClassCTimeout))
	}
	l = len(m.MACVersion)
	if l > 0 {
		n += 1 + l + sovProfiles(uint64(l))
	}
	l = len(m.RegParamsRevision)
	if l > 0 {
		n += 1 + l + sovProfiles(uint64(l))
	}
	if m.RXDelay1 != 0 {
		n += 1 + sovProfiles(uint64(m.RXDelay1))
	}
	if m.RXDROffset1 != 0 {
		n += 1 + sovProfiles(uint64(m.RXDROffset1))
	}
	if m.RXDataRate2 != 0 {
		n += 1 + sovProfiles(uint64(m.RXDataRate2))
	}
	if m.RXFreq2 != 0 {
		n += 1 + sovProfiles(uint64(m.RXFreq2))
	}
	if len(m.FactoryPresetFreqs) > 0 {
		l = 0
		for _, e := range m.FactoryPresetFreqs {
			l += sovProfiles(uint64(e))
		}
		n += 1 + sovProfiles(uint64(l)) + l
	}
	if m.MaxEIRP != 0 {
		n += 2 + sovProfiles(uint64(m.MaxEIRP))
	}
	if m.MaxDutyCycle != 0 {
		n += 2 + sovProfiles(uint64(m.MaxDutyCycle))
	}
	if m.SupportsJoin {
		n += 3
	}
	l = len(m.RFRegion)
	if l > 0 {
		n += 2 + l + sovProfiles(uint64(l))
	}
	if m.Supports32BitFCnt {
		n += 3
	}
	return n
}

func (m *RoutingProfile) Size() (n int) {
	var l int
	_ = l
	l = m.ID.Size()
	n += 1 + l + sovProfiles(uint64(l))
	l = len(m.ASID)
	if l > 0 {
		n += 1 + l + sovProfiles(uint64(l))
	}
	l = len(m.CACert)
	if l > 0 {
		n += 1 + l + sovProfiles(uint64(l))
	}
	l = len(m.TLSCert)
	if l > 0 {
		n += 1 + l + sovProfiles(uint64(l))
	}
	l = len(m.TLSKey)
	if l > 0 {
		n += 1 + l + sovProfiles(uint64(l))
	}
	return n
}

func sovProfiles(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozProfiles(x uint64) (n int) {
	return sovProfiles(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ServiceProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProfiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ULRate", wireType)
			}
			m.ULRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ULRate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ULBucketSize", wireType)
			}
			m.ULBucketSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ULBucketSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ULRatePolicy", wireType)
			}
			m.ULRatePolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ULRatePolicy |= (RatePolicy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DLRate", wireType)
			}
			m.DLRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DLRate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DLBucketSize", wireType)
			}
			m.DLBucketSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DLBucketSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DLRatePolicy", wireType)
			}
			m.DLRatePolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DLRatePolicy |= (RatePolicy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddGWMetaData", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddGWMetaData = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevStatusReqFreq", wireType)
			}
			m.DevStatusReqFreq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DevStatusReqFreq |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportDevStatusBattery", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReportDevStatusBattery = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportDevStatusMargin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReportDevStatusMargin = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DRMin", wireType)
			}
			m.DRMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DRMin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DRMax", wireType)
			}
			m.DRMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DRMax |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelMask", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelMask = append(m.ChannelMask[:0], dAtA[iNdEx:postIndex]...)
			if m.ChannelMask == nil {
				m.ChannelMask = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PRAllowed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PRAllowed = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HRAllowed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HRAllowed = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RAAllowed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RAAllowed = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NwkGeoLoc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NwkGeoLoc = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPER", wireType)
			}
			m.TargetPER = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetPER |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinGWDiversity", wireType)
			}
			m.MinGWDiversity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinGWDiversity |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProfiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProfiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProfiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsClassB", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsClassB = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassBTimeout", wireType)
			}
			m.ClassBTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassBTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PingSlotPeriod", wireType)
			}
			m.PingSlotPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PingSlotPeriod |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PingSlotDR", wireType)
			}
			m.PingSlotDR = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PingSlotDR |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PingSlotFreq", wireType)
			}
			m.PingSlotFreq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PingSlotFreq |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsClassC", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsClassC = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassCTimeout", wireType)
			}
			m.ClassCTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassCTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MACVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegParamsRevision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegParamsRevision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RXDelay1", wireType)
			}
			m.RXDelay1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RXDelay1 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RXDROffset1", wireType)
			}
			m.RXDROffset1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RXDROffset1 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RXDataRate2", wireType)
			}
			m.RXDataRate2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RXDataRate2 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RXFreq2", wireType)
			}
			m.RXFreq2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RXFreq2 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProfiles
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FactoryPresetFreqs = append(m.FactoryPresetFreqs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProfiles
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProfiles
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProfiles
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FactoryPresetFreqs = append(m.FactoryPresetFreqs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FactoryPresetFreqs", wireType)
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxEIRP", wireType)
			}
			m.MaxEIRP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxEIRP |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDutyCycle", wireType)
			}
			m.MaxDutyCycle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDutyCycle |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsJoin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsJoin = bool(v != 0)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RFRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RFRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supports32BitFCnt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Supports32BitFCnt = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProfiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProfiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoutingProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProfiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoutingProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoutingProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ASID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ASID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CACert", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CACert = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSCert", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TLSCert = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TLSKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProfiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProfiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProfiles(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProfiles
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthProfiles
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProfiles
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProfiles(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProfiles = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProfiles   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("profiles.proto", fileDescriptorProfiles) }

var fileDescriptorProfiles = []byte{
	// 1226 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x4f, 0x6f, 0xdb, 0x36,
	0x1f, 0xae, 0xd3, 0xc4, 0x7f, 0x68, 0x4b, 0x71, 0x98, 0xf6, 0x85, 0xde, 0x17, 0x78, 0x23, 0xaf,
	0x1d, 0xba, 0xac, 0x68, 0x93, 0xc6, 0x19, 0x36, 0x74, 0xd8, 0xc5, 0xb6, 0x9a, 0x2c, 0x6d, 0x8c,
	0x1a, 0x74, 0xb2, 0xf6, 0x46, 0xd0, 0x22, 0xed, 0x70, 0x91, 0x44, 0x85, 0xa2, 0x13, 0xbb, 0xb7,
	0x7d, 0xad, 0x7d, 0x82, 0x1e, 0x77, 0xde, 0x41, 0x18, 0x74, 0xdf, 0x77, 0x18, 0x48, 0xc9, 0x76,
	0xd2, 0x62, 0xc7, 0x9e, 0x44, 0x3e, 0xbf, 0xe7, 0xf9, 0xf9, 0x21, 0xa9, 0x87, 0x32, 0xb0, 0x63,
	0x29, 0xc6, 0x3c, 0x60, 0xc9, 0x5e, 0x2c, 0x85, 0x12, 0x70, 0x2d, 0x4a, 0xfe, 0xf7, 0x7c, 0xc2,
	0xd5, 0xc5, 0x74, 0xb4, 0xe7, 0x8b, 0x70, 0x7f, 0x22, 0x26, 0x62, 0xdf, 0x94, 0x46, 0xd3, 0xb1,
	0x99, 0x99, 0x89, 0x19, 0xe5, 0x92, 0x47, 0xbf, 0x55, 0x81, 0x3d, 0x64, 0xf2, 0x9a, 0xfb, 0x6c,
	0x90, 0x37, 0x83, 0xaf, 0xc1, 0x1a, 0xa7, 0x4e, 0xa9, 0x55, 0xda, 0x6d, 0x74, 0x7f, 0xfc, 0x98,
	0xba, 0xf7, 0xfe, 0x4c, 0xdd, 0x67, 0xb7, 0xba, 0x8e, 0xa4, 0xf0, 0x09, 0x91, 0xfb, 0x81, 0x90,
	0x24, 0x61, 0xf2, 0x9a, 0xc9, 0x7d, 0x12, 0xf3, 0x7d, 0x35, 0x8f, 0x59, 0xb2, 0x77, 0x7e, 0x7e,
	0xe2, 0x65, 0xa9, 0xbb, 0x76, 0xe2, 0xa1, 0x35, 0x4e, 0xe1, 0x63, 0x50, 0x99, 0x06, 0x58, 0x12,
	0xc5, 0x9c, 0xb5, 0x56, 0x69, 0xd7, 0xea, 0x82, 0x2c, 0x75, 0xcb, 0xe7, 0xa7, 0x88, 0x28, 0x86,
	0xca, 0xd3, 0x40, 0x3f, 0xe1, 0xf7, 0xc0, 0x9e, 0x06, 0x78, 0x34, 0xf5, 0x2f, 0x99, 0xc2, 0x09,
	0xff, 0xc0, 0x9c, 0xfb, 0x86, 0xdb, 0xcc, 0x52, 0xb7, 0x71, 0x7e, 0xda, 0x35, 0x85, 0x21, 0xff,
	0xc0, 0x50, 0x63, 0x1a, 0xac, 0x66, 0xf0, 0xc8, 0xe8, 0x74, 0x73, 0x1c, 0x8b, 0x80, 0xfb, 0x73,
	0x67, 0xbd, 0x55, 0xda, 0xb5, 0xdb, 0xf6, 0x5e, 0x94, 0xec, 0xe9, 0xce, 0x03, 0x83, 0x2e, 0xfa,
	0xac, 0x10, 0xdd, 0x67, 0x35, 0xd3, 0x26, 0x69, 0x61, 0x72, 0x63, 0x65, 0xd2, 0x2b, 0x4c, 0xd2,
	0xa5, 0x49, 0x7a, 0xd7, 0x64, 0x79, 0x65, 0xd2, 0xbb, 0x63, 0x92, 0x7e, 0x62, 0x92, 0xde, 0x35,
	0x59, 0xf9, 0x77, 0x93, 0xde, 0x1d, 0x93, 0xf4, 0xb6, 0xc9, 0x97, 0x60, 0x93, 0x50, 0x8a, 0x27,
	0x37, 0x38, 0x64, 0x8a, 0x50, 0xa2, 0x88, 0x53, 0x6d, 0x95, 0x76, 0xab, 0xdd, 0xad, 0x2c, 0x75,
	0xad, 0x0e, 0xa5, 0xc7, 0xef, 0xfa, 0x4c, 0x11, 0x8f, 0x28, 0x82, 0x2c, 0x42, 0xe9, 0xf1, 0x4d,
	0xbf, 0xe0, 0xc1, 0xe7, 0x60, 0x9b, 0xb2, 0x6b, 0x9c, 0x28, 0xa2, 0xa6, 0x09, 0x96, 0xec, 0x0a,
	0x8f, 0x25, 0xbb, 0x72, 0x6a, 0xda, 0x3f, 0x6a, 0x52, 0x76, 0x3d, 0x34, 0x15, 0xc4, 0xae, 0x8e,
	0x24, 0xbb, 0x82, 0x2f, 0xc1, 0x7f, 0x25, 0x8b, 0x85, 0x54, 0xf8, 0x96, 0x6a, 0x44, 0x94, 0x62,
	0x72, 0xee, 0x00, 0xfd, 0x9b, 0xe8, 0x3f, 0x39, 0xc1, 0x5b, 0x48, 0xbb, 0x79, 0x15, 0xfe, 0x00,
	0x9c, 0xcf, 0xa5, 0x21, 0x91, 0x13, 0x1e, 0x39, 0x75, 0xa3, 0x7c, 0xf8, 0x89, 0xb2, 0x6f, 0x8a,
	0xb0, 0x05, 0xca, 0x54, 0xe2, 0x90, 0x47, 0x4e, 0xc3, 0xec, 0x6a, 0x2d, 0x4b, 0xdd, 0x0d, 0x0f,
	0xf5, 0x79, 0x84, 0x36, 0xa8, 0xec, 0xaf, 0x18, 0x64, 0xe6, 0x58, 0x77, 0x18, 0x64, 0x66, 0x18,
	0x64, 0x06, 0xbf, 0x02, 0x0d, 0xff, 0x82, 0x44, 0x11, 0x0b, 0x70, 0x48, 0x92, 0x4b, 0xc7, 0xd6,
	0x6f, 0x30, 0xaa, 0x17, 0x58, 0x9f, 0x24, 0x97, 0xf0, 0x19, 0x00, 0xb1, 0xc4, 0x24, 0x08, 0xc4,
	0x0d, 0xa3, 0xce, 0xa6, 0xd9, 0x3f, 0x2b, 0x4b, 0xdd, 0xda, 0x00, 0x75, 0x72, 0x10, 0xd5, 0x62,
	0x59, 0x0c, 0x35, 0xfb, 0x62, 0xc5, 0x6e, 0xae, 0xd8, 0x3f, 0xaf, 0xd8, 0x17, 0xb7, 0xd9, 0x92,
	0x2c, 0xd9, 0x5b, 0x2b, 0x36, 0xea, 0x2c, 0xd9, 0x92, 0x2c, 0xd8, 0x3b, 0xa0, 0x1e, 0xdd, 0x5c,
	0xe2, 0x09, 0x13, 0x38, 0x10, 0xbe, 0x03, 0xcd, 0xe6, 0xd4, 0xa2, 0x9b, 0xcb, 0x63, 0x26, 0x4e,
	0x85, 0xaf, 0xbb, 0x29, 0x22, 0x27, 0x4c, 0xe1, 0x98, 0x49, 0x67, 0xdb, 0x2c, 0xd9, 0x74, 0x3b,
	0x33, 0xe8, 0xe0, 0x15, 0x42, 0xb5, 0x9c, 0x30, 0x60, 0x12, 0xfe, 0x04, 0x9a, 0x21, 0x8f, 0xf4,
	0xcb, 0x41, 0xf9, 0x35, 0x93, 0x09, 0x57, 0x73, 0xe7, 0x81, 0xd1, 0xc0, 0x2c, 0x75, 0xed, 0x3e,
	0x8f, 0x8e, 0xdf, 0x79, 0x8b, 0x0a, 0xb2, 0x43, 0x1e, 0x1d, 0xdf, 0x2c, 0xe7, 0x8f, 0x7e, 0xaf,
	0x00, 0xcb, 0x63, 0x5f, 0xea, 0x0a, 0xd8, 0x05, 0xcd, 0x64, 0x1a, 0xeb, 0x43, 0x4f, 0xb0, 0x1f,
	0x90, 0x24, 0xc1, 0x23, 0x73, 0x17, 0x54, 0x91, 0xbd, 0xc0, 0x7b, 0x1a, 0xee, 0xc2, 0x27, 0x60,
	0xb3, 0x20, 0x60, 0xc5, 0x43, 0x26, 0xa6, 0x2a, 0xbf, 0x08, 0x90, 0x65, 0xe0, 0xee, 0x59, 0x0e,
	0xea, 0x8e, 0x31, 0x8f, 0x26, 0x38, 0x09, 0x84, 0xd9, 0x1e, 0x2e, 0xa8, 0x49, 0xbe, 0x85, 0x6c,
	0x8d, 0x0f, 0x03, 0xa1, 0x37, 0x85, 0x0b, 0x0a, 0x5f, 0x80, 0xc6, 0x8a, 0x49, 0x65, 0x11, 0x6f,
	0x3b, 0x4b, 0x5d, 0x30, 0x28, 0x98, 0x1e, 0x42, 0x60, 0xa1, 0xf2, 0x24, 0xfc, 0x1a, 0xd8, 0x2b,
	0x85, 0x89, 0x89, 0x89, 0x39, 0x6a, 0x2c, 0x38, 0x26, 0x22, 0x9f, 0xaf, 0xc9, 0x37, 0xb1, 0xfe,
	0x74, 0x4d, 0xbd, 0xd5, 0x9a, 0xfc, 0xe5, 0x9a, 0xaa, 0xb7, 0xd6, 0xd4, 0x5b, 0xac, 0x69, 0x1f,
	0xd4, 0x43, 0xe2, 0x63, 0x73, 0x24, 0x22, 0x32, 0xd9, 0xac, 0xe5, 0x46, 0xfb, 0x9d, 0xde, 0x2f,
	0x39, 0x8a, 0x40, 0x48, 0xfc, 0x62, 0x0c, 0xf7, 0xc0, 0xb6, 0x64, 0x13, 0x1c, 0x13, 0x49, 0x42,
	0x1d, 0xea, 0x6b, 0x6e, 0x84, 0x3a, 0x9f, 0x35, 0xb4, 0x25, 0xd9, 0x64, 0x60, 0x2a, 0xa8, 0x28,
	0xc0, 0xa7, 0x00, 0xc8, 0x19, 0xa6, 0x2c, 0x20, 0x73, 0x7c, 0x60, 0xc2, 0x68, 0x75, 0x1b, 0x59,
	0xea, 0x56, 0xd1, 0x7b, 0x4f, 0x83, 0x07, 0xa8, 0x2a, 0x67, 0xf9, 0x08, 0x7e, 0x07, 0x6c, 0xcd,
	0x95, 0x58, 0x8c, 0xc7, 0x09, 0x53, 0xf8, 0xa0, 0x48, 0xe5, 0x66, 0x96, 0xba, 0x75, 0xf4, 0xde,
	0x43, 0x6f, 0x0d, 0x7e, 0x80, 0xea, 0x72, 0xe6, 0xc9, 0x62, 0x02, 0x0f, 0x81, 0xa5, 0x55, 0x44,
	0x11, 0x73, 0xdb, 0xb5, 0x8b, 0xa0, 0x2e, 0x44, 0xfa, 0x62, 0x22, 0x8a, 0xb5, 0x8d, 0xa8, 0x20,
	0xb5, 0xe1, 0x37, 0xa0, 0x26, 0x67, 0x66, 0xa3, 0x71, 0xdb, 0x24, 0xd6, 0xea, 0xd6, 0xb3, 0xd4,
	0xad, 0xa0, 0xf7, 0x7a, 0xa3, 0xdb, 0xa8, 0x22, 0x67, 0x66, 0x00, 0x5f, 0x80, 0x07, 0x63, 0xe2,
	0x2b, 0x21, 0xe7, 0x38, 0x96, 0x4c, 0xbb, 0xd2, 0xa2, 0xc4, 0xd9, 0x6c, 0xdd, 0xdf, 0xb5, 0x10,
	0x2c, 0x6a, 0x03, 0x53, 0xd2, 0x8a, 0x04, 0x3e, 0x01, 0xd5, 0x90, 0xcc, 0x30, 0xe3, 0x32, 0x36,
	0xe1, 0x2d, 0x3a, 0xf7, 0xc9, 0xec, 0xd5, 0x09, 0x1a, 0xa0, 0x4a, 0x48, 0x66, 0xaf, 0xb8, 0x8c,
	0xf5, 0x91, 0x6b, 0x1e, 0x9d, 0xaa, 0x39, 0xf6, 0xe7, 0x7e, 0xc0, 0x4c, 0x78, 0x2d, 0xd4, 0x08,
	0xc9, 0xcc, 0x9b, 0xaa, 0x79, 0x4f, 0x63, 0xf0, 0x31, 0xb0, 0x96, 0x47, 0xfe, 0xab, 0xe0, 0x51,
	0x11, 0xd9, 0xc6, 0x02, 0x7c, 0x2d, 0x78, 0x04, 0xbf, 0x05, 0x35, 0x39, 0xc6, 0x92, 0x4d, 0xf4,
	0x51, 0x6c, 0x9b, 0x33, 0xcc, 0xf7, 0xf8, 0x08, 0x19, 0x0c, 0x55, 0xe5, 0x38, 0x1f, 0xc1, 0x23,
	0xf0, 0x60, 0xd9, 0xef, 0xb0, 0x3d, 0xe2, 0x0a, 0x8f, 0xb1, 0x1f, 0x29, 0x13, 0xdb, 0x6a, 0xf7,
	0x61, 0x96, 0xba, 0x5b, 0xc3, 0xa2, 0x7e, 0xd8, 0xee, 0x72, 0x75, 0xd4, 0x8b, 0x14, 0xda, 0x4a,
	0x96, 0xd0, 0x28, 0x87, 0x1e, 0xfd, 0x5d, 0x02, 0x36, 0x12, 0x53, 0xc5, 0xa3, 0xc9, 0x97, 0x48,
	0xef, 0xff, 0xc1, 0x06, 0x49, 0x30, 0xa7, 0x26, 0xb2, 0xb5, 0x6e, 0x35, 0x4b, 0xdd, 0xf5, 0xce,
	0xf0, 0xc4, 0x43, 0xeb, 0x24, 0x39, 0x31, 0xdf, 0x77, 0x9f, 0x60, 0x9f, 0xc9, 0x3c, 0xaa, 0xb5,
	0xfc, 0xd3, 0xd9, 0xeb, 0xf4, 0x98, 0x54, 0xa8, 0xec, 0x13, 0xfd, 0xd4, 0x07, 0xa1, 0x82, 0x24,
	0x67, 0xad, 0x1b, 0x96, 0x39, 0x88, 0xb3, 0xd3, 0xa1, 0xa1, 0x55, 0x54, 0x90, 0x18, 0xde, 0x63,
	0xa0, 0x87, 0xf8, 0x92, 0xcd, 0x4d, 0x50, 0x8b, 0x66, 0x67, 0xa7, 0xc3, 0x37, 0x6c, 0x8e, 0xca,
	0x2a, 0x48, 0xde, 0xb0, 0xf9, 0xd3, 0x16, 0x00, 0xb7, 0xbe, 0x8a, 0x55, 0xb0, 0xee, 0xa1, 0xb7,
	0x83, 0xe6, 0x3d, 0x3d, 0xea, 0x77, 0xd0, 0x9b, 0x66, 0xa9, 0xdb, 0xf8, 0x98, 0xed, 0x94, 0xfe,
	0xc8, 0x76, 0x4a, 0x7f, 0x65, 0x3b, 0xa5, 0x51, 0xd9, 0xfc, 0xcf, 0x39, 0xfc, 0x27, 0x00, 0x00,
	0xff, 0xff, 0xeb, 0xcc, 0x4c, 0x8e, 0x2c, 0x09, 0x00, 0x00,
}
